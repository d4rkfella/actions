name: 'Build single package with Melange'
description: |
  This action generates a package using Melange. It assumes that
  the Melange repository is already configured.

inputs:
  config:
    description: |
      'The config file to use for building the package.'
    default: ./melange.yaml
    required: false

  config-file-license:
    description: |
      'License to use for the melange config itself.'
    default: Apache-2.0

  arch:
    description: |
      'Architecture to build for.'
    default: x86_64
    required: false

  sign-package:
    default: false
    required: false

  signing-key:
    description: 'Private key for signing packages (pass GitHub secret here)'
    required: false
    default: ''

  output-dir:
    description: |
      'Directory where package will be written.'
    default: ${{ github.workspace }}/packages
    required: false

  tests-repository-append:
    description: |
      'A list of paths or URIs of repositories that should be implicitly included in the test environment.'
    default: ''
    required: false

  repository-append:
    description: |
      'A list of paths or URIs of repositories that should be implicitly included in the build environment.'
    default: ''
    required: false

  tests-keyring-append:
    description: |
      'A list of paths or URIs of keys that should be included in the test environment.'
    default: ''
    required: false

  keyring-append:
    description: |
      'A list of paths or URIs of keys that should be included in the build environment.'
    default: ''
    required: false

  workspace-dir:
    description: |
      'The directory to use as the workspace.'
    default: ''
    required: false

  maintainer:
    description: |
      'Namespace string to use in SBOM purls identifying the maintainer of the artifact'
    default: ''
    required: false

  empty-workspace:
    description: |
      'Whether to use an empty workspace or not.'
    default: false
    required: false

  source-dir:
    description: |
      'The source directory to use if empty-workspace is false.'
    default: ${{ github.workspace }}
    required: false

  cache-dir:
    description: |
      'Directory used for cached inputs.'
    default: ''
    required: false

  pipeline-dir:
    description: |
      'Directory used for pipelines.'
    default: ${{ github.workspace }}/pipelines
    required: false

  git-commit:
    description: |
      'Commit hash of the git repository containing the build config file.'
    default: ''
    required: false

  git-repo-url:
    description: |
      'URL of the git repository containing the build config file.'
    default: ''
    required: false

  artifactory-url:
    required: true

  artifactory-repository-path:
    required: true
  
  artifactory-access-token:
    required: true

  jfrog-cli-version:
    required: false
    default: 2.84.0

runs:
  using: 'composite'

  steps:
    - name: Setup JFrog CLI
      uses: jfrog/setup-jfrog-cli@5b06f730cc5a6f55d78b30753f8583454b08c0aa # v4.8.1
      env:
        version: ${{ inputs.jfrog-cli-version }}
        JF_URL: ${{ inputs.artifactory-url }}
        JF_ACCESS_TOKEN: ${{ inputs.artifactory-access-token }}

    - name: Set JFROG_CLI_BUILD_NAME
      shell: bash
      run: |
        PKG_NAME=$(yq -r '.package.name' "${{ inputs.config }}")
        echo "JFROG_CLI_BUILD_NAME=$PKG_NAME" >> "$GITHUB_ENV"

    - name: Set signing key from secret
      id: signing_key
      if: ${{ inputs.sign-package == 'true' }}
      shell: bash
      run: |
        if [[ -z "${{ inputs.signing-key }}" ]]; then
          echo "Error: sign-package is enabled but signing-key input is not set."
          exit 1
        fi
        
        KEY_PATH="${RUNNER_TEMP}/.melange/melange-signing.rsa"
        mkdir -p "$(dirname "$KEY_PATH")"
        chmod 700 "$(dirname "$KEY_PATH")"
        echo "${{ inputs.signing-key }}" > "$KEY_PATH"
        chmod 400 "$KEY_PATH"
        echo "signing-key-path=$KEY_PATH" >> "$GITHUB_OUTPUT"
    
    - name: Check for existing repositories in Melange config
      id: check_config_repos
      shell: bash
      run: |
        if [[ $(yq eval '(.environment.contents.repositories | length // 0) > 0' "${{ inputs.config }}" 2>/dev/null) == "true" ]]; then
          echo "has_config_repos=true" >> "$GITHUB_OUTPUT"
        else
          echo "has_config_repos=false" >> "$GITHUB_OUTPUT"
        fi
    
    - name: Build package
      shell: bash
      run: |
        args=()
        args+=(build "${{ inputs.config }}" --generate-provenance=false --package-append busybox --license "${{ inputs.config-file-license }}" --arch "${{ inputs.arch }}" --out-dir "${{ inputs.output-dir }}")

        if [[ "${{ steps.check_config_repos.outputs.has_config_repos }}" == "false" ]]; then
          [ -n "${{ inputs.repository-append }}" ] && args+=(--repository-append "${{ inputs.repository-append }}")
          [ -n "${{ inputs.keyring-append }}" ] && args+=(--keyring-append "${{ inputs.keyring-append }}")
        fi
        
        [ -n "${{ inputs.workspace-dir }}" ] && args+=(--workspace-dir "${{ inputs.workspace-dir }}")
        [ -n "${{ inputs.maintainer }}" ] && args+=(--namespace "${{ inputs.maintainer }}")
        [ -n "${{ inputs.cache-dir }}" ] && args+=(--cache-dir "${{ inputs.cache-dir }}")
        [ -n "${{ inputs.pipeline-dir }}" ] && args+=(--pipeline-dir "${{ inputs.pipeline-dir }}")
        [ -n "${{ inputs.git-commit }}" ] && args+=(--git-commit "${{ inputs.git-commit }}")
        [ -n "${{ inputs.git-repo-url }}" ] && args+=(--git-repo-url "${{ inputs.git-repo-url }}")

        if [[ "${{ inputs.empty-workspace }}" == "true" ]]; then
          args+=(--empty-workspace)
        else
          args+=(--source-dir "${{ inputs.source-dir }}/$(dirname "${{ inputs.config }}")")
        fi

        if [[ "${{ inputs.sign-package }}" == "true" ]]; then
          args+=(--signing-key "${{ steps.signing_key.outputs.signing-key-path }}")
        fi

        sudo melange "${args[@]}"

    - name: Check for reproducible build flag
      id: is_reproducible
      shell: bash
      run: |
        REPRODUCIBLE=$(yq eval '.environment.environment.REPRODUCIBLE' "${{ inputs.config }}")
    
        if [ -z "$REPRODUCIBLE" ] || [ "$REPRODUCIBLE" = "null" ]; then
          REPRODUCIBLE="true"
        fi

        echo "REPRODUCIBLE=$REPRODUCIBLE" >> $GITHUB_ENV
        echo "reproducible=$REPRODUCIBLE" >> $GITHUB_OUTPUT

    - name: Rebuild package
      if: steps.is_reproducible.outputs.reproducible == 'true'
      shell: bash
      run: |
        args=()
        args+=(rebuild "${{ inputs.output-dir }}"/"${{ inputs.arch }}"/*.apk)

        if [[ "${{ inputs.sign-package }}" == "true" ]]; then
          args+=(--signing-key "${{ steps.signing_key.outputs.signing-key-path }}")
        fi

        if [[ "${{ inputs.empty-workspace }}" == "true" ]]; then
          args+=(--empty-workspace)
        else
          args+=(--source-dir "${{ inputs.source-dir }}/$(dirname "${{ inputs.config }}")")
        fi
        
        sudo melange "${args[@]}"

    - name: Fix output path permissions
      shell: bash
      run: |
        sudo chown -R runner:runner ${{ inputs.output-dir }}
    
    - name: Test package
      shell: bash
      run: |
        args=()
        args+=(test "${{ inputs.config }}" --arch "${{ inputs.arch }}" --test-package-append busybox)
    
        args+=(--repository-append "${{ inputs.output-dir }}")

        if [[ "${{ inputs.sign-package }}" == 'true' ]]; then
          openssl pkey -in "${{ steps.signing_key.outputs.signing-key-path }}" -pubout \
            -out "${{ steps.signing_key.outputs.signing-key-path }}.pub"
          args+=(--keyring-append "${{ steps.signing_key.outputs.signing-key-path }}.pub")
        fi
    
        [ -n "${{ inputs.tests-repository-append }}" ] && args+=(--repository-append "${{ inputs.tests-repository-append }}")
        [ -n "${{ inputs.tests-keyring-append }}" ] && args+=(--keyring-append "${{ inputs.tests-keyring-append }}")
        [ -n "${{ inputs.workspace-dir }}" ] && args+=(--workspace-dir "${{ inputs.workspace-dir }}")
        [ -n "${{ inputs.pipeline-dir }}" ] && args+=(--pipeline-dirs "${{ inputs.pipeline-dir }}")
    
        if [[ "${{ inputs.empty-workspace }}" == "true" ]]; then
          args+=(--empty-workspace)
        else
          args+=(--source-dir "${{ inputs.source-dir }}/$(dirname "${{ inputs.config }}")")
        fi
    
        sudo melange "${args[@]}"
    
    - name: Upload artifacts
      shell: bash
      run: |
        pushd "${{ inputs.output-dir }}/${{ inputs.arch }}"
        for apk in *.apk; do
          echo "Uploading $apk..."
          jf rt upload "$apk" "${{ inputs.artifactory-repository-path }}/${{ inputs.arch }}/$apk"
        done
        popd
