name: 'Build single package with Melange'
description: |
  This action generates a package using Melange. It assumes that
  the Melange repository is already configured.

inputs:
  config:
    description: |
      'The config file to use for building the package.'
    default: ./melange.yaml

  config-file-license:
    description: |
      'License to use for the melange config itself.'
    default: Apache-2.0

  arch:
    description: |
      'Architecture to build for.'
    default: x86_64

  sign-with-temporary-key:
    default: false

  sign-with-key:
    default: false

  signing-key-path:
    description: |
      'The filepath of the signing key file. Only configure this value if signing is set to true.'
    default: ''

  output-dir:
    description: |
      'Directory where packages will be output.'
    default: ${{ github.workspace }}/packages

  tests-repository-append:
    description: |
      'A list of paths or URIs of repositories that should be implicitly included in the test environment.'
    default: ''

  repository-append:
    description: |
      'A list of paths or URIs of repositories that should be implicitly included in the build environment.'
    default: ''

  tests-keyring-append:
    description: |
      'A list of paths or URIs of keys that should be included in the test environment.'
    default: ''

  keyring-append:
    description: |
      'A list of paths or URIs of keys that should be included in the build environment.'
    default: ''

  workspace-dir:
    description: |
      'The directory to use as the workspace.'
    default: ''

  maintainer:
    description: |
      'Namespace string to use in SBOM purls identifying the maintainer of the artifact'
    default: ''

  empty-workspace:
    description: |
      'Whether to use an empty workspace or not.'
    default: false

  source-dir:
    description: |
      'The source directory to use if empty-workspace is false.'
    default: ${{ github.workspace }}

  cache-dir:
    description: |
      'Directory used for cached inputs.'
    default: ''

  pipeline-dir:
    description: |
      'Directory used for pipelines.'
    default: ${{ github.workspace }}/pipelines

  git-commit:
    description: |
      'Commit hash of the git repository containing the build config file.'
    default: ''

  git-repo-url:
    description: |
      'URL of the git repository containing the build config file.'
    default: ''

  build-date:
    default: true

  artifactory-url:
    default: ''

  artifactory-url-path:
    default: ''
  
  artifactory-access-token:
    default: ''

runs:
  using: 'composite'

  steps:
    - name: Validate inputs
      shell: bash
      run: |
        if [[ "${{ inputs.sign-with-key }}" == "true" && "${{ inputs.sign-with-temporary-key }}" == "true" ]]; then
          echo "Error: Both 'sign-with-key' and 'sign-with-temporary-key' cannot be enabled at the same time."
          exit 1
        fi
        if [[ ("${{ inputs.sign-with-key }}" == "true" || "${{ inputs.sign-with-temporary-key }}" == "true") && -z "${{ inputs.signing-key-path }}" ]]; then
          echo "Error: 'signing-key-path' cannot be empty when 'sign-with-key' or 'sign-with-temporary-key' is enabled."
          exit 1
        fi

    - name: Setup JFrog CLI
      uses: jfrog/setup-jfrog-cli@v4
      env:
        JF_URL: ${{ inputs.artifactory-url }}
        JF_ACCESS_TOKEN: ${{ inputs.artifactory-access-token }}

    - name: Set global variables
      shell: bash
      run: |
        PKG_NAME=$(yq -r '.package.name' "${{ inputs.config }}")
        PKG_VERSION=$(yq -r '.package.version' "${{ inputs.config }}")
        PKG_EPOCH=$(yq -r '.package.epoch // 0' "${{ inputs.config }}")

        echo ARTIFACT_NAME="${PKG_NAME}-${PKG_VERSION}-r${PKG_EPOCH}" >> "$GITHUB_ENV"
        echo "JFROG_CLI_BUILD_NAME=$PKG_NAME" >> "$GITHUB_ENV"
    
    - name: Set build date
      shell: bash
      id: build-date
      if: ${{ inputs.build-date == 'true' }}
      run: |
        echo "build-date=$(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> "$GITHUB_OUTPUT"

    - name: Generate temporary signing key
      if: ${{ inputs.sign-with-temporary-key == 'true' && inputs.signing-key-path != '' }}
      shell: bash
      run: |
        melange keygen "${{ inputs.signing-key-path }}"

    - name: Set signing key from secret
      if: ${{ inputs.sign-with-key == 'true' && inputs.signing-key-path != '' }}
      shell: bash
      run: |
        echo -n "$MELANGE_PRIVATE_KEY" > "${{ inputs.signing-key-path }}"
        chmod 400 "${{ inputs.signing-key-path }}"
    
    - name: Check for existing repositories in Melange config
      id: check_config_repos
      shell: bash
      run: |
        if [[ $(yq eval '(.environment.contents.repositories | length // 0) > 0' "${{ inputs.config }}" 2>/dev/null) == "true" ]]; then
          echo "has_config_repos=true" >> "$GITHUB_OUTPUT"
        else
          echo "has_config_repos=false" >> "$GITHUB_OUTPUT"
        fi
    
    - name: Build package
      shell: bash
      run: |
        args=()
        args+=(build "${{ inputs.config }}" --generate-provenance=true --package-append busybox --license "${{ inputs.config-file-license }}" --arch "${{ inputs.arch }}" --out-dir "${{ inputs.output-dir }}")

        if [[ "${{ steps.check_config_repos.outputs.has_config_repos }}" == "false" ]]; then
          [ -n "${{ inputs.repository-append }}" ] && args+=(--repository-append "${{ inputs.repository-append }}")
          [ -n "${{ inputs.keyring-append }}" ] && args+=(--keyring-append "${{ inputs.keyring-append }}")
        fi
        
        [ -n "${{ inputs.workspace-dir }}" ] && args+=(--workspace-dir "${{ inputs.workspace-dir }}")
        [ -n "${{ inputs.namespace }}" ] && args+=(--namespace "${{ inputs.maintainer }}")
        [ -n "${{ inputs.cache-dir }}" ] && args+=(--cache-dir "${{ inputs.cache-dir }}")
        [ -n "${{ inputs.pipeline-dir }}" ] && args+=(--pipeline-dir "${{ inputs.pipeline-dir }}")
        [ -n "${{ inputs.git-commit }}" ] && args+=(--git-commit "${{ inputs.git-commit }}")
        [ -n "${{ inputs.git-repo-url }}" ] && args+=(--git-repo-url "${{ inputs.git-repo-url }}")
        [ -n "${{ steps.build-date.outputs.build-date }}" ] && args+=(--build-date "${{ steps.build-date.outputs.build-date }}")

        if [[ "${{ inputs.empty-workspace }}" == "true" ]]; then
          args+=(--empty-workspace)
        else
          args+=(--source-dir "${{ inputs.source-dir }}/$(dirname "${{ inputs.config }}")")
        fi

        if [[ "${{ inputs.sign-with-key }}" == "true" || "${{ inputs.sign-with-temporary-key }}" == "true" ]]; then
          args+=(--signing-key "${{ inputs.signing-key-path }}")
        fi

        sudo melange "${args[@]}"

    - name: Check for reproducible build flag
      id: is_reproducible
      shell: bash
      run: |
        REPRODUCIBLE=$(yq eval '.environment.environment.REPRODUCIBLE' "${{ inputs.config }}")
    
        if [ -z "$REPRODUCIBLE" ] || [ "$REPRODUCIBLE" = "null" ]; then
          REPRODUCIBLE="true"
        fi

        echo "REPRODUCIBLE=$REPRODUCIBLE" >> $GITHUB_ENV
        echo "reproducible=$REPRODUCIBLE" >> $GITHUB_OUTPUT

    - name: Rebuild package
      if: steps.is_reproducible.outputs.reproducible == 'true'
      shell: bash
      run: |
        args=()
        args+=(rebuild "${{ inputs.output-dir }}"/"${{ inputs.arch }}"/*.apk)

        if [[ "${{ inputs.sign-with-key }}" == "true" || "${{ inputs.sign-with-temporary-key }}" == "true" ]]; then
          args+=(--signing-key "${{ inputs.signing-key-path }}")
        fi

        if [[ "${{ inputs.empty-workspace }}" == "true" ]]; then
          args+=(--empty-workspace)
        else
          args+=(--source-dir "${{ inputs.source-dir }}/$(dirname "${{ inputs.config }}")")
        fi
        
        sudo melange "${args[@]}"

    - name: Fix output path permissions
      shell: bash
      run: |
        sudo chown -R runner:runner ${{ inputs.output-dir }}
    
    - name: Test package
      shell: bash
      run: |
        args=()
        args+=(test "${{ inputs.config }}" --arch "${{ inputs.arch }}" --test-package-append busybox)
    
        if [[ -d "${{ inputs.output-dir }}" ]]; then
          args+=(--repository-append "${{ inputs.output-dir }}")
          args+=(--keyring-append "${{ inputs.signing-key-path }}.pub")
        fi
    
        [ -n "${{ inputs.tests-repository-append }}" ] && args+=(--repository-append "${{ inputs.tests-repository-append }}")
        [ -n "${{ inputs.tests-keyring-append }}" ] && args+=(--keyring-append "${{ inputs.tests-keyring-append }}")
        [ -n "${{ inputs.workspace-dir }}" ] && args+=(--workspace-dir "${{ inputs.workspace-dir }}")
        [ -n "${{ inputs.pipeline-dir }}" ] && args+=(--pipeline-dirs "${{ inputs.pipeline-dir }}")
    
        if [[ "${{ inputs.empty-workspace }}" == "true" ]]; then
          args+=(--empty-workspace)
        else
          args+=(--source-dir "${{ inputs.source-dir }}/$(dirname "${{ inputs.config }}")")
        fi
    
        sudo melange "${args[@]}"
    
    - name: Upload artifact
      shell: bash
      run: |
        pushd "${{ inputs.output-dir }}/${{ inputs.arch }}"
        jf rt upload "$ARTIFACT_NAME.apk" "${{ inputs.artifactory-url-path }}/${{ inputs.arch }}/$ARTIFACT_NAME.apk"

    - name: Create artifact digest
      id: create_artifact_digest
      shell: bash
      run: |
        ARTIFACT_PATH="${{ inputs.output-dir }}/${{ inputs.arch }}/$ARTIFACT_NAME.apk"
        DIGEST=$(sha256sum "$ARTIFACT_PATH" | awk '{print "sha256:"$1}')
        echo "ARTIFACT_DIGEST=$DIGEST" >> "$GITHUB_ENV"

    - name: Extract SLSA predicate from the attestation file
      id: extract_prov
      shell: bash
      run: |
        PROVENANCE_FILEPATH="${{ inputs.output-dir }}/${{ inputs.arch }}/$ARTIFACT_NAME.attest.tar.gz"
        DEST_DIR="${{ inputs.output-dir }}/${{ inputs.arch }}/attestations"
    
        if [[ ! -f "$PROVENANCE_FILEPATH" ]]; then
          echo "❌ No attestation archive found at $PROVENANCE_FILEPATH"
          exit 1
        fi
    
        mkdir -p "$DEST_DIR"
        tar -xzf "$PROVENANCE_FILEPATH" -C "$DEST_DIR"
    
        PROV_FILE=$(find "$DEST_DIR" -type f -name '*.attestation' | head -n1)
        if [[ -z "$PROV_FILE" ]]; then
          echo "❌ No .attestation file found after extraction"
          exit 1
        fi
        
        PREDICATE_PATH="${PROV_FILE}.predicate.json"
        jq '.predicate' "$PROV_FILE" > "$PREDICATE_PATH"
    
        echo "✅ Extracted predicate to: $PREDICATE_PATH"
        echo "slsa_provenance_path=$PREDICATE_PATH" >> "$GITHUB_OUTPUT"

    - name: Create custom attestation
      uses: actions/attest@daf44fb950173508f38bd2406030372c1d1162b1 #v3.0.0
      with:
        subject-digest: ${{ env.ARTIFACT_DIGEST }}
        subject-name: >-
          ${{ inputs.artifactory-url-path }}/${{ inputs.arch }}/${{ env.ARTIFACT_NAME }}.apk
        predicate-type: "https://example.com/attestations/custom-review-v1"
        predicate: |
          {
            "creationTime": "${{ github.event.repository.pushed_at }}",
            "reviewer": "darkfella",
            "repository": "${{ github.repository }}"
          }

    - name: Create SLSA v1.0 attestation
      uses: actions/attest@daf44fb950173508f38bd2406030372c1d1162b1 #v3.0.0
      with:
        subject-name: >-
          ${{ inputs.artifactory-url-path }}/${{ inputs.arch }}/${{ env.ARTIFACT_NAME }}.apk
        subject-digest: ${{ env.ARTIFACT_DIGEST }}
        predicate-type: https://chainguard.dev/provenance/slsa/v1
        predicate-path: ${{ steps.extract_prov.outputs.slsa_provenance_path }}
